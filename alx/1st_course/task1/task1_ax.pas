program num5;

{$APPTYPE CONSOLE}
{
  Задача:
  Создать линейный однонаправленный список, состоящий из вещественных чисел.
  Удалить элементы, которые меньше по модулю, чем 5.
}

uses
  SysUtils;


const
  module = 5.00; { объявляем константу 5 }

{ объявляем новый тип данных для элементов нашего списка }
type
  Pointer = ^node; { указатель будет типа node }
  node = record    { объявляем тип node как запись (структура данных). Такой тип будет иметь каждый элемент списка }
    value: real;   { значение каждого элемента списка будет вещественным - тип real }
    next: Pointer; { каждый элемент списка будет ссылаться только на следующий элемент (т.к. однонаправленный список) }
  end;

{ объявляем переменные }
var
  head, elem, prev: Pointer; { head - это всегда первый элемент списка; elem - текущий элемент списка (который обрабатываетя), prev - предыдущий элемент списка }
  i, amount: integer; { i - счетчик в циклах, amount - всего количество элементов списка }
  buffer: real; { необязательная промежуточная переменная для чтения данных пользоателя и записи значения в текущий элемент списка }
begin

  writeln('Fill list...');

  { обнуляем все переменные и указатели, чтобы не поймать неизвестных значений }
  head := nil;
  elem := nil;
  prev := nil;
  i := 0; amount := 0;
  buffer := 0;


  { узнаем какое количество элементов будет в нашем списке }
  write(' How many elements you need in list? (write number) ');
  readln(amount); writeln;

  { необязательно! если значение 0 или меньше, то такого списка не может существовать }
  if (amount < 1) then begin
    writeln(' You wrote bad value: ', amount, ' and move to default value: 4.');
    amount := 4; { сбрасываем некорректное значение на стандартное значение 4. У нас будет 4 элемента списка. }
  end;

  { Создаем все элементы списка и связываем их между собой }
  for i:= 1 to amount do begin
    write(' Please, write value in: ', i, ' element: ');
    readln(buffer); { записать значение пользователя для элемента i в промежуточную переменную buffer }

    prev := elem; { присвоить prev (предыдущий элемент списка) значение elem }
    new(elem);    { создаем новый элемент в переменную elem }
    elem^.value := buffer; { записываем в новый элемент введенное пользователем значение }

    { если мы добавили первый элемент списка,
        то присвоить указатель на этот элемент в head
      иначе если это не первый элемент,
        то присвоить предыдущему элементу списка ссылку на текущий элемент }
    if (head = nil) then
      head := elem
    else
      prev^.next := elem;

    { присвоить текущему элементу ссылку на первый элемент списка (т.к. добавялем всегда в конец).
      тогда получится замкнутый список (как в кружок) }
    elem^.next := head;
  end;


  { Блок вывода на экран всех элементов, которые ввел пользователь }
  writeln; writeln(' Output result of user inputs... '); writeln;

  i := 0;
  elem := head;
  repeat
    i := i + 1;
    write(' Element number ', i, ':');
    writeln(elem^.value:3:2);
    elem := elem^.next;
  until (elem = head);


  { Блок: Начинаем поиск первого элемента, значение которого по модулю меньше 5, затем удалим его }
  writeln; writeln(' Delete first element with value: abs(x) < 5. '); writeln;

  { находим последний элемент, т.к. если удалим head, то нельзя допустить, чтобы последний элемент все еще ссылался на удаленный head
    этого условия не будет, если список не замкнутый, т.к. в таком списке последний элемент не ссылкается на head }
  elem := head; { сделать текущим первый элемент }
  repeat
    prev := elem; { присвоить предыдущий элемент в prev }
    elem := elem^.next; { и переключаемся на следующий элемент }
    if (elem = head) then writeln(' Last element of list found!'); { просто сообщаем, что последний элемент найден}
  until (elem = head); { до тех пор, пока текущий элемент не станет равен первому элементу (тогда prev равен последнему элементу)}


  { Начинаем удаление элемента по условию }
  i := 0; { обнуляем переменные и ставим указатель в начало списка head }
  elem := head;
  repeat
    i:= i + 1;
    { выводим значение текущего элемента }
    write(' Element number ', i, ':  ');
    writeln(elem^.value:3:2);


    { если значение текущего элемента по модулю меньше нашей константы 5.00, то удаляем элемент }
    if (abs(elem^.value) < module) then begin
      writeln(' Delete ', i, ' element with value ', elem^.value:3:2); { вывести сообщение об удалении элемента }
      prev^.next := elem^.next; { ссылка на следущий элемент в предыдущем элементе теперь будет ссылаться на следующий элемент (который после текущего)
                                  то есть мы удаляем ссылку на текущий элемент (elem) и к нему больше не будет доступа }

      { необязательные проверки }
      if (elem = head) AND (elem^.next = head) then begin { если мы удалили единственный элемент списка}
        elem := nil; { то обнулить все переменные }
        head := nil;
      end else if (elem = head) then {или если мы удалили первый элемент списка}
        head := elem^.next; { присвоить в head значение второго элемента списка (теперь он стал первым) }

      break; { прервать цикл, так как нам нужно удалить только первый элемент и нет смысла продолжать }
    end;

    { если текущий элемент по модулю больше 5.00, то преключиться на следующий элемент списка }
    prev := elem; { сделать предыдущим элементом списка текущий элемент }
    elem := elem^.next; { сделать текущим элементом списка следующий элемент }
  until (elem = head); { цикл до тех пор, пока не дойдем до первого элемента списка (значит прошли весь список и вышли на 2-й круг) }


  { выводим получившейся список }
  writeln; writeln(' Output final result without removed element... '); writeln;

  { обнуляем все переменные }
  i := 0;
  elem := head; { ставим указатель в начало списка }
  repeat
    i := i + 1;
    { если head = nil, то есть не имеет указателя, то списка не существует. Он был удален. }
    if (head = nil) then begin
      writeln(' List been deleted' ); { вывести об этом сообщение }
      break; { прервать цикл }
    end;
    write(' Element number ', i, ':');
    writeln(elem^.value:3:2); { иначе выводим значение текущего элемента }
    elem := elem^.next; { переключаемся на следующий }
  until (elem = head); { пока не дойдем до первого элемента (на 2-й круг) }

  readln;
end.
