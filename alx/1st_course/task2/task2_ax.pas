program num6;

{$APPTYPE CONSOLE}
{
  Задача:
  Создать линейный двунаправленный список, состоящий из целых чисел.
  Удалить из списка элементы, идущие после элементов со значением 4.
  Вставить элемент со значением 0 перед каждым элементом со значением 1.
}

uses
  SysUtils;

{ объявляем новый тип данных для элементов нашего списка }
type
  Pointer = ^node; { указатель будет типа node }
  node = record    { объявляем тип node как запись (структура данных). Такой тип будет иметь каждый элемент списка }
    value: integer;{ значение каждого элемента списка будет целочисленным - тип integer }
    next, prev: Pointer; { каждый элемент списка будет ссылаться как на следующий элемент, так и на предыдущий (т.к. двунаправленный список) }
  end;

var
  head, elem, prev: Pointer; { head - это всегда первый элемент списка; elem - текущий элемент списка (который обрабатываетя), prev - предыдущий элемент списка }
  i, amount: integer; { i - счетчик в циклах, amount - всего количество элементов списка }
  buffer: integer; { необязательная промежуточная переменная для чтения данных пользоателя и записи значения в текущий элемент списка }
begin

  { обнуляем все переменные и указатели, чтобы не поймать неизвестных значений }
  head := nil;
  elem := nil;
  prev := nil;
  i := 0; amount := 0;
  buffer := 0;

  { узнаем какое количество элементов будет в нашем списке }
  write(' How many elements you need in list? (write number) ');
  readln(amount); writeln;

  { необязательно! если значение 0 или меньше, то такого списка не может существовать }
  if (amount < 1) then begin
    writeln(' [!] You wrote bad value: ', amount, ' and move to default value: 4.');
    amount := 4; { сбрасываем некорректное значение на стандартное значение 4. У нас будет 4 элемента списка. }
  end;

  { Создаем все элементы списка и связываем их между собой }
  for i:= 1 to amount do begin
    write(' Please, write value in: ', i, ' element: ');
    readln(buffer); { записать значение пользователя для элемента i в промежуточную переменную buffer }

    prev := elem;   { присвоить prev (предыдущий элемент списка) значение elem }
    new(elem);      { создаем новый элемент в переменную elem }
    elem^.value := buffer; { записываем в новый элемент введенное пользователем значение }

    { если мы добавили первый элемент списка,
        то присвоить указатель на этот элемент в head и ссылку на предыдущий элемент сделать head
      иначе если это не первый элемент,
        то присвоить предыдущему элементу списка ссылку на текущий элемент, а текущему элементу - ссылку на предыдущий }
    if (head = nil) then begin
      head := elem;
      elem^.prev := head;
    end else begin
      prev^.next := elem;
      elem^.prev := prev;
    end;

    { присвоить текущему элементу ссылку на первый элемент списка (т.к. добавялем всегда в конец).
      и присвоить первому элементу списка ссылку на новый последний элемент.
      тогда получится замкнутый список (как в кружок) }
    elem^.next := head;
    head^.prev := elem;
  end;


 { Блок вывода на экран всех элементов, которые ввел пользователь }
  writeln; writeln(' Output result of user inputs... '); writeln;

  i := 0;
  elem := head;
  repeat
    i := i + 1;
    write(' Element number ', i, ':');
    writeln(elem^.value);
    elem := elem^.next;
  until (elem = head);


  { Необязательно: такой же Блок вывода, но в обратную сторону, чтобы показать, что список двунаправленный }
  writeln; writeln(' Output INVERSE result of user inputs... '); writeln;

  i := 0;
  elem := head;
  repeat
    i := i + 1;
    elem := elem^.prev; { переключиться на предыдущий элемент (в первой итерации это первый с конца элемент, потом второй с конца и т.д.) }
    write(' Element number ', i, ':');
    writeln(elem^.value); { вывести значение }
  until (elem = head); { пока не дойдем до 1-го элемента }


  { Блок: Начинаем и удаление всех элементов, которые стоят после элементов со значением 4. }
  writeln; writeln(' Delete every element after all elements with value 4. '); writeln;

  { последний элемент искать не нужно, т.к. список двунаправленный и в head имеет ссылка на последний элемент списка (кружок же) }
  { Начинаем удаление элемента по условию }
  i := 0;
  elem := head; { сделать текущим первый элемент }
  repeat
    i:= i + 1;
    { выводим значение текущего элемента }
    write(' Element number ', i, ':  ');
    writeln(elem^.value);

    { если значение текущего элемента равно 4, то удаляем следующий элемент }
    if (elem^.value = 4) then begin
      writeln(' Delete ', i+1, ' element with value ', elem^.next^.value); { вывести сообщение об удалении элемента }

      { в этот раз сначала проверки, а потом удаление, т.к. ссылка на текущий элемент только одна }

      { необязательные проверки }
      if (elem = head) AND (elem^.next = head) then begin { если мы удалим единственный элемент списка }
        elem := nil; { то обнулить все переменные }
        head := nil;
      end else if (elem^.next = head) then begin {или если мы удалим первый элемент списка}
        head := head^.next; { присвоить в head значение второго элемента списка (теперь он стал первым) }
        head^.prev := elem; { и добавить в head ссылку на текущий элемент (на последний), вместо удаленного элемента (первого в списке) }
      end;

      { текущему элементу присвоить ссылку на элемент, после следующего (удаленного) }
      { из-за чего удаленный элемент будет недоступен и удален }
      elem^.next := elem^.next^.next;
    end;

    elem := elem^.next; { переключиться на следующий элемент списка }
  until (elem = head); { цикл до тех пор, пока не дойдем до первого элемента списка (значит прошли весь список и вышли на 2-й круг) }


  { выводим получившейся список }
  writeln; writeln(' Output result after deleting elements... '); writeln;

  { обнуляем все переменные }
  i := 0;
  elem := head; { ставим указатель в начало списка }
  repeat
    i := i + 1;
    { если head = nil, то есть не имеет указателя, то списка не существует. Он был удален. }
    if (head = nil) then begin
      writeln(' List been deleted' ); { вывести об этом сообщение }
      break; { прервать цикл }
    end;
    write(' Element number ', i, ':');
    writeln(elem^.value); { иначе выводим значение текущего элемента }
    elem := elem^.next; { переключаемся на следующий }
  until (elem = head); { пока не дойдем до первого элемента (на 2-й круг) }


  { проверка: если список еще существует (имеет хотя бы 1 элемент, то продолжаем) }

  if (NOT(head = nil)) then begin

  	  { Необходимо изменить значения всех элементов списка на 0, которые стоят перед элементом со значением 1. }
	  writeln; writeln(' Change value of element if next element with value 1. '); writeln;

	  { обнуляем все переменные }
  	  i := 0;
   	  elem := head; { ставим указатель в начало списка }
	  repeat
	    i:= i + 1;
	    write(' Element number ', i, ':  ');
	    writeln(elem^.value); { выводим значение текущего элемента }

	    { если значение следующего элемента равно 1, то изименить значение текущего элемента на 0. }
	    if (elem^.next^.value = 1) then begin
	      writeln(' Change ', i, ' element with value ', elem^.value); { выводим сообщение }
	      elem^.value := 0; { меняем значение текущего элемента }
	    end;

	    { переключаемся на следующий элемент }
	    elem := elem^.next;
	  until (elem = head); { пока не достигнем 1-го элемента списка }


	  { вывести весь список }
	  writeln; writeln(' Output final result without removed element... '); writeln;

	  { обнуляем все переменные }
	  i := 0;
	  elem := head; { ставим указатель в начало списка }
	  repeat
	    i := i + 1;
	    write(' Element number ', i, ':');
	    writeln(elem^.value); { выводим значение текущего элемента }
	    elem := elem^.next; { переключаемся на следующий элемент }
	  until (elem = head); { пока не достигнем 1-го элемента списка }
  end;

  readln;
end.
